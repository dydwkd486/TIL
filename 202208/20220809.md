# 20220809

## heap 관련해서 SC 지식 정리
<aside>
💡 **완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조**

</aside>

## 힙이란?

- 힙(heap): 데이터에서 **최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리**(Complete Binary Tree)
    - 완전 이진 트리: 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리
- 힙은 일종의 반정렬 상태(느슨한 정렬 상태) 를 유지한다.
    - 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
    - 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
- 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

---

## 힙을 사용하는 이유

- 배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n) 이 걸림
- 이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, O(log n)이 걸림
- 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨

---

## 힙의 종류

- 최대 힙(max heap)
    - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
- 최소 힙(min heap)
    - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

---

## 힙 vs 이진 탐색 트리

- 공통점 : 힙과 이진 탐색 트리는 모두 이진 트리로 구성
- 차이점 :
    - 힙은 각 노드의 값이 자식 노드 보다 크거나 같으나 이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼
    - 힙은 이진 탐색 트리의 조건인 자식 노드에서 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음. → 다시말해 자식노드의 값이 오른쪽이 클수도 왼쪽이 클수도 있음.
    - 이진 탐색 트리는 **탐색을 위한 구조** 이며, 힙은 **최대, 최소를 찾는 구조**

---

## **힙(heap)의 구현**

- 힙을 저장하는 표준적인 자료구조는 **배열** 이다.
- 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
- 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.
    - 예를 들어 루트 노드의 오른쪽 노드의 번호는 항상 3이다.
- 힙에서의 부모 노드와 자식 노드의 관계
    - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
    - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
    - 부모의 인덱스 = (자식의 인덱스) / 2

## ****힙(heap)의 삽입****

1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.

![Untitled](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-insertion.png)

## **힙(heap)의 삭제**

1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
    - 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다.

![Untitled](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-delete.png)

---

## Java의 메모리 구조를 통해 보는 Stack 과 heap의 차이점

- 스택은 정적 메모리, 힙은 동적 메모리에 저장
- 스택은 함수,지역변수,매개변수가 저장되며 LIFO 방식으로 관리되지만 힙 영역은 전역 변수를 다루며 사용자가 직접 관리해야 하는 메모리 영역

---

### 스택

- 정적 메모리 할당
- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역
- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출
- 후입선출(LIFO, Last-In First-Out) 방식
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당

**장점**

- 매우 빠른 액세스(할당,해제가 빠르다)
- 변수를 명시적으로 할당 해제 할 필요가 없다.

**단점**

- 메모리 크기 제한
- 지역 변수만

---

### 힙

- 동적 메모리 할당
- 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역
- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당

**장점**

- 변수는 전역적으로 액세스 할 수 있다.
- 메모리 크기 제한이 없다.**단점**
- 상대적으로 느린 액세스(할당,해제가 느리다)
- 메모리를 관리해야 한다.(변수를 할당하고 해제하는 책임이 있다)
- 운영체제마다 메모리 관리가 다르기 때문에 어렵다.

---

### 레퍼런스

- [https://velog.io/@bbkyoo/면접준비자료구조8힙](https://velog.io/@bbkyoo/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B08%ED%9E%99)
- [https://beforb.tistory.com/6#Java3](https://beforb.tistory.com/6#Java3)
- [https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)