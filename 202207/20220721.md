# 20220721

oop is A.P.I.E

Abstraction(추상화) 현실의 객체를 추상화해서 클래스를 구성

Polymorphism(다형성) 하나의 객체를 여러가지 타입(형)으로 참조할 수 있다.

Inheritance(상속) 부모 클래스의 자산을 물려받아 자식을 정의함으로 코드의 재사용이 가능하다.

Encapsulation(데이터 은닉과 보호) 데이터를 외부에 직접 노출시키지 않고 메서드를 이용하여 보호 할 수 있다.

## 1. 상속

기존 클래스의 자산(멤버)를 자식 클래스에서 재사용하기 위한 것

부모의 생성자와 초기화 블록은 상속하지 않는다.

기존 클래스의 멤버를 물려 받기 때문에 코드의 절감할수있다.

부모의 코드를 변결하면 모든 자식들에게도 적용 → 유지 보수성 향상

상속의 적용

extends 키워드 사용

### 다양한 상속 관계

상속의 관계는 is a 관계라고함.

person is a Object, SpiderMan is a person

### 단일 상속

다중 상속의 경우 여러클래스의 기능을 물려받을 수 있으나 관계가 매우 복잡해짐

자바는 단일 상속만 지원

대신 interface와 포함 관계(has a)로 단점 극복

### 포함 관계

상속 이외에 클래스를 재활용하는 방법

2개 이상의 클래스에서 특성을 가져올 때 하나는 상속, 나머지는 멤버 변수로 처리

포함관계의 ULM 표현 : 실선

Spider의 코드를 수정하면 SpiderMan에도 반영 되므로 유지 보수성 확보

## 2. 매서드 재정의

매서드 오버라이딩

오버라이딩의 조건

- 매서드 이름은 같아야 한다.
- 매개변수의 개수,타입,순서가 같아야한다.
- 리턴타입이 같아야한다.
- 접근 제한자는 부모 보다 범위가 넓거나 같아야 한다.
- 조상보다 더 큰 예외를 던질 수 없다.

### Annotation

- 사전적 의미:주석
- 컴파일러, JVM, 프레임워크 등이 보는 주석
- 소스코드에 메타 데이터를 삽입하는 형태
    - 소스 코드에 붙여 놓은 라벨
    - 코드에 대한 정보 추가 → 소스코드의 구조 변경, 환경 설정 정보 추가 등의 작업을 진행한다.
- JDK 1.5의 기본 annotation의 예
    - @Deprecated
        - 컴파일러에게 해당 메서드가 deprecated 되었다고 알려줌.
    - @Override
        - 컴파일러에게 해당 메서드는 override한 메서드 임을 알려줌
        - @Override 가 선언된 경우 반드시 super class에 선언 되어있는 매서드여야 한다.
    - @SuppressWarnings
        - 컴파일러에게 사소한 warning의 경우 신경 쓰지 말라고 알려줌.
    - 
    

## super 키워드

- 변수의 scope
    - 사용된 위치에서 점점 확장해가며 처음 만난 선언부에 연결됨
    - method 내부 → 해달 클래스 멤버변수 → 조상 클래스 멤버 변수
- this() 가 해당 클래스의 다른 생성자를 호출하듯 super()는 조상 클래스의 생성자를 호출한다.
    - 조상클래스에 선언된 멤버들은 조상 클래스의 생성자에서 초기화가 이뤄지므로 이를 재활용
    - 자식 클래스에 선언된 멤버들만 자식 클래스 생성자에서 초기화
- super() 자식 클래스 생성자의 맨 첫 줄에서만 호출 가능
    - 즉 생성자의 첫 줄에만 this(), super() 가 올 수 있다.
- 명시적으로 this() 또는 super()를 호출하지 않는 경우 컴파일러가 super() 삽입
    - 결론적으로 맨 상위의 Object까지 객체가 다 만들어지는 구조
- 

## package

- 프로그램의 많은 클래스 → 패키지 이용
    - 패키지의 이름은 의미 있는 이름으로 만들고 ‘.’ 을 통해 계층적으로 접근한다.
    - 물리적으로 패키기는 클래스 파일을 담고 있는 디렉터리이다.
- package의 선언
    - package package_name;
    - 주석,공백을 제외한 첫 번째 문장에 하나의 패키지만 선언
    - 모든 클래스는 반드시 하나의 패키지에 속한다.
        - 생략시 default package
        - default package는 사용하지 않는다. (사용하지마!)
- 일반적인 package naming 룰
    - 소속.프로젝트.용도
    - com.ssafy.htm.commin

## import

- 다른 패키지에 선언된 클래스를 사용하기 위한 키워드
    - 패키지와 클래스 선언 사이에위치
    - 패키지와 달리 여러번 선언 가능
- 선언 방법
    - import 패키지명.클래스명;
    - import 패키지명.*;
        - 하위 패키지까지 import 하지는 않는다.
- import 한 package의 클래스 이름이 동일하여 명확히 구분해야 할때
    - 클래스 이름 앞에 전체  패키지 명을 입력
- default import package
    - java.lang.*;
    - 

## final

마지막, 더이상 바뀔 수 없음.

용도

이미 완벽한 경우에는 바꿀필요가 없기에 사용함.

## 3. 접근 제한자 및 데이터 은닉과 보호

### 객체의 생성 제어와 singleton 디자인 패턴

- 객체의 생성을 제한해야 한다면?
    - 객체를 구별 할 필요가 없는 경우 = 수정 가능한 멤버 변수가 없고 기능만 있는 경우
    - 이런 객체 stateless 한 객체라고 한다.
- 객체를 계속 생성, 삭제하는데 많은 비용이 들어서 재사용이 유리한 경우

### Singleton 디자인 패턴

- 외부에서 생성자에 접근 금지 → 생성자의 접근 제한자를 private으로 설정
- 내부세서는 private에 접근 가능하므로 직접 객체 생성 → 멤버 변수이므로 private 설정
- 외부에서 private member에 접근 가능한 getter 생성 → setter는 불필요
- 객체 없이 외부에서 접근 할 수 있도록 getter와 변수에 static 추가
- 외부에서는 언제나 getter를 통해서 객체를 참조하므로 하나의 객체 재사용

## 다형성 Polymorphism

### 하나의 객체가 많은 형을 가질 수 있는 성질

- 황금잉어빵 is a 붕어빵
- 다형성의 정의
    - 상속 관계에 있을 조상 클래스의 타입으로 자식 클래스 객체를 레퍼런스 할 수 있다.
- 다형성의 활용 예 1- **다른 타입의 객체를 다루는 배열**
    - 배열의 특징 - 같은 타입의 데이터를 묶음으로 다룬다.
    - 다형성으로 다른 타입의 데이터를 하나의 배열로 관리
    - Object는 모든 클래스의 조상
        - Object의 배열은 어떤 타입의 객체라도 다 저장할 수 있음.
    - 자바의 자료 구조를 간단하게 처리할 수 있음.
        - 이와 같은 특성을 이용하여 collection API가 등장하게 됨.
    - 기본형은 담을 수 없지만 autoboxing되어서 담을 수 있다.

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/44c7fb53-c5cd-4a0d-bfc5-f4e15b7b57e2/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220721%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220721T134231Z&X-Amz-Expires=86400&X-Amz-Signature=9944012fa100f32028f4e9ae5c6534035c36c802b4930f730ca1ad91262f02f4&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- 다형성의 활용 예 2- 매개변수의 다형성
    - API에서 파라미터로 Object를 받는다는 것은 모든 객체를 처리한다는 말이다.
- 참조형 객체의 형변환
    - 자식에서 부모로 갈때는 묵시적 형변환
    - 부모에서 자식으로 갈떄는 명시적 형변환을 해야한다.
    - instanceof 로 확인하고 형변환하면 됨.
- 참조 변수의 레벨에 따른 객체의 멤버 연결
    - 상속 관계에서 객체의 멤버 변수가 중복될때 → 참조변수의 타입에 따라 연결이 달라짐
    - 상속 관계에서 객체의 메서드가 중복될 때(메서드가 override 되었을때)
        - 무조건 자식 클래스의 메서드가 호출됨.
        - 최대한 메모리에 생성된 실제 객체에 최적화 된 메서드가 동작한다.
    - 상위로 올라갈 수록 활용도도 높아짐
        - 하지만 코드가 복잡성도 함께 증가
    - Java API 처럼 공통 기능인 경우 Object를 파라미터로 쓰겠지만
        - 많은 경우 비즈니스 로직상 최상위 객체 사용권장

equals 메서드

객체의 주소 비교: ==활용

객체의 내용 비교: equals 재정의