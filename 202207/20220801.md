# SW 문제 해결

## SW 문제 해결 역량이란 무엇인가?

- 프로그래밍을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
- 문제 해결 역량은 추상적인 기술이다.
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
    - 무작성 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

## 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 문제 해결 전략

- 직관과 체계적인 접근

### 체계적인 접근을 위한 질문들

- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화 할 수 있을까?
- 그림으로 그려 볼 수 있을까?
- 수식으로 표현 할 수 있을까?
- 문제를 분해 할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?
- 정렬하고 풀 수 있을까?

### 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.
- 컴퓨터 분야에서 알고리즘을 표현하는 방법은 크게 두가지
    - 의사코드와 순서도
        - 최소 의사코드를 알아야 시간복잡도를 유추할 수 있다.

## 알고리즘 성능

### 무엇이 좋은 알고리즘인가?

1. **정확성: 얼마나 정확하게 동작하는가(기본)**
2. **작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가**
3. **메모리 사용량: 얼마나 적은 메모리를 사용하는가**
4. 단순성: 얼마나 단순한가
5. 최적성: 더 이상 개선할 여지 없이 최적화 되었는가
- 보통 1억 연산에 1초 정도 걸린다.(10의8승)

### 시간 복잡도 : 연산의 작업량, 수행시간

- 최선의 경우 (Best Case)
    - 빅오메가 표기법사용
    - 최선의 시나리오로 최소 시간이 걸림
- 최악의 경우(worst Case)
    - 빅오 표기법사용
    - 최악의 시나리오로 아무리 오래 걸려도 이시간보다 덜 걸림
- 평균적인 경우(Average Case)
    - 빅 세타 표기법 사용
    - 평균 시간을 나타냄

### 공간 복잡도: 메모리 사용량

### ex)N개의 서로 다른 데이터가 저장되어 있는 배열에서 원하는 값X를 탐색하는 알고리즘에서의 시간 복잡도는?

- 최선의 경우 : 1
- 최악의 경우 : N
- 평균의 경우 : n/2

### 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능

⇒ 어떤 알고리즘을 사용해야하는가?

### 알고리즘의 성능 분석 필요

- 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

### 복잡도의 점근적표기

- 시간(또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.

### 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영량력을 주는 n에 대한 항만을 표기
- 계수는 생략하여 표시
- 예시 : O(3n+2) ⇒ O(n)
- nlogn으로 줄일수 있다면 BEST!!


---
# 재귀 호출

## 반복과 재귀

### 반복과 재귀는 유사한 작업을 수행한다.

### 반복은 수행하는 작업이 완료될 때까지 계속 반복

- 루프(for/while, do~while 구조)

### 재귀는 주어진 문제의 해를 구하기 위해 **동일**하면서 **더 작은 문제의 해**를 이용하는 방법

- 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.
- 재귀함수 구현

### 재귀 함수(recursive function)

- 함수 내부에서 **직접 혹은 간접적으로 자기 자신을 호출하는 함수**. → 자신을 통해 자신을 정의!
    1. 함수에 대한 정의를 명확히 해라!
    2. **Flat**하게 평평하게 로직을 바라보기!
    3. 각 재귀의 실행을 결정하는 결정요인은 **매개변수**로 선언
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현한다.
- 따라서, 기본 부분과 유도 부분으로 구성된다.
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
    - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그매이 어렵다고 느낀다.
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다.
- 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다.

### 반복 또는 재귀?

- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
    - 추상 자료형의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.
- 일반적으로, 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.
- 입력 값 n이 커질수록 재귀알고리즘은 반복에 비해 비효육적일수 있다.

|  | 재귀 | 반복 |
| --- | --- | --- |
| 종료 | 재귀 함수 호출이 종료되는 
베이스 케이스 | 반복문의 종료 조건 |
| 수행 시간 | 느림 | 빠름 |
| 메모리 공간 | 많이 사용 | 적게 사용 |
| 소스코드 길이  | 짧고 간결 | 길다 |
| 소스 코드 형태 | 선택 구조 | 반복 구조 |
| 무한 반복 | 스택 오버플로우 | CPU를 반복해서 점유 |

## 피보나치 수열

- 이전의 두 수항으로 하는 수열을 피보나치라 한다.
- 피보나치 수열의 i번 째 값을 계산하는 함수 F를 정의하면 다음과 같다.

$$
F_0=0,F_1=1 \\
F_i=F_{i-1}+F_{i-2} for i\geq2
$$

- 위의 정의로 부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다.
- 피보나치 수를 구하는 재귀함수

```java
fibo(n)
	IF n<2 : RETURN n
	ELSE   : RETURN fibo(n-1) + fibo(n-2)
```

- 앞의 예에서 피보나치 수를 구하는 함수를 재귀함수로 구현한 알고리즘은 문제점이 있다.
- 엄청난 중복 호출이 존재한다.는 것!

### 메모이제이션

- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술
- 피보나치 수를 구하는 알고리즘에서 fibo1(n)의 값을 계산하자마자 저장 하면, 실행 시간을 O(n)으로 줄일 수 있다.

```java
mono[0] <- 0
mono[1] <- 1
fibo1(n)
	IF n>=2 AND memo[n] =0
			momo[n] <-fibo1(n-1)+fibo(n-2)
	RETURN memo[n]
```

## 하노이 탑

직접 해보세요~ 라고 함.

근데 계산해보면

1개면 1번

2개면 3번

3개면 7번

이렇게 된다면.. 2의 n승 -1을 하면 된다.

4개면? 2의4승 -1 ⇒ 16-1 = 15가 된다.

---